<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-Annotation</title>
    <link href="/2024/01/30/Java-Annotation/"/>
    <url>/2024/01/30/Java-Annotation/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h1><h2 id="1-Override和-Authwired和-Resource"><a href="#1-Override和-Authwired和-Resource" class="headerlink" title="1.@Override和@Authwired和@Resource"></a>1.@Override和@Authwired和@Resource</h2><p>（1）@Override注解是伪代码，表示子类重写父类的方法<br>（2）@Authwired和@Resource区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">区别：@Autowired跟Spring框架强耦合了，如果换成其他框架，@Autowired就没作用了。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持<br>包含的属性：@Autowired只包含一个参数：required，表示是否开启自动注入，默认是<span class="hljs-literal">true</span>。而@Resource包含七个参数，其中最重要的两个参数是：name 和 <span class="hljs-built_in">type</span><br>装配规则：Autowired默认按byType自动装配，而@Resource默认byName自动装配<br>注解应用的地方不同：@Autowired能够用在：构造器、方法、参数、成员变量和注解上<br>@Resource能用在：类、成员变量和方法上<br>什么时候用：Autowired按类型查找，书写方便，不用在后面跟名字，缺点：当一个Service有多个ServiceImpl去实现时，那么会报错，因为它不知道去实现哪一个。Resource按名字查找，后面要跟参数name，好处：当有多个Impl实现类时，可以通name快速找到<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode206</title>
    <link href="/2024/01/26/Leetcode206/"/>
    <url>/2024/01/26/Leetcode206/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-206-翻转链表"><a href="#Leetcode-206-翻转链表" class="headerlink" title="Leetcode 206 - 翻转链表"></a>Leetcode 206 - 翻转链表</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image206.png" alt="Alt text"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>迭代和递归都可以解决，迭代逻辑上更好理解，假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode* aft = cur -&gt; next;<br>            cur -&gt; next = pre;<br>            pre = cur;<br>            cur = aft;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode328</title>
    <link href="/2024/01/26/Leetcode328/"/>
    <url>/2024/01/26/Leetcode328/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-328-奇偶链表"><a href="#Leetcode-328-奇偶链表" class="headerlink" title="Leetcode 328 - 奇偶链表"></a>Leetcode 328 - 奇偶链表</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/odd-even-linked-list/description/">https://leetcode.cn/problems/odd-even-linked-list/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。<br>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。<br>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。<br>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image328.png" alt="Alt text"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,4,5]<br>输出: [1,3,5,2,4]<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>题目要求O(1)的空间复杂度，则只能用链表这个数据结构去解决问题，新建节点在原链表上处理</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* evenHead = head -&gt; next;<br>        ListNode* odd = head;<br>        ListNode* even = evenHead;<br>        <span class="hljs-keyword">while</span> (even &amp;&amp; even -&gt; next) &#123;<br>            odd -&gt; next = even -&gt; next;<br>            odd = odd -&gt; next;<br>            even -&gt; next = odd -&gt; next;<br>            even = even -&gt; next;<br>        &#125;<br>        odd -&gt; next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2865</title>
    <link href="/2024/01/26/Leetcode2865/"/>
    <url>/2024/01/26/Leetcode2865/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2865-美丽塔I"><a href="#Leetcode-2865-美丽塔I" class="headerlink" title="Leetcode 2865 - 美丽塔I"></a>Leetcode 2865 - 美丽塔I</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/beautiful-towers-i/description/">https://leetcode.cn/problems/beautiful-towers-i/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。<br>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。<br>如果以下条件满足，我们称这些塔是 美丽 的：<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]<br>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：<br>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]<br>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：maxHeights = [5,3,4,1,1]<br>输出：13<br>解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：<br>- 1 &lt;= heights[i] &lt;= maxHeights[i]  <br>- heights 是个山脉数组，峰值在 i = 0 处。<br>13 是所有美丽塔方案中的最大高度和<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>结合单调栈，用动态规划计算前缀后缀和</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-comment">//单调栈+前缀和</span><br>        <span class="hljs-comment">//max(prefix[i] + suffix[i] - maxHeights[i])</span><br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//单调非递减栈，栈里存的是索引</span><br>        <span class="hljs-comment">//左侧的非递减，i依次入栈，对第i个元素，不断从栈顶弹出比i大的元素，直到栈顶元素小于等于maxHeights[i]，假设此时栈顶元素为maxHeights[j]，则区间[j + 1, i - 1]之间的元素可以取到maxHeights[i]，此时prefix[i] = prefix[j] + (i - j) * maxHeights[i];</span><br>        <span class="hljs-comment">//左侧的非递增，就是右侧的非递减</span><br>        <span class="hljs-comment">//右侧的非递减，i依次入栈，对第i个元素，不断从栈顶弹出比i大的元素，直到栈顶元素小于等于maxHeights[i]，假设此时栈顶元素为maxHeights[j]，则区间[i + 1, j - 1]之间的元素可以取到maxHeights[i]，此时prefix[i] = prefix[j] + (j - i) * maxHeights[i];</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk1,stk2;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n)</span>, <span class="hljs-title">suffix</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">//处理单调非递减</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stk1.<span class="hljs-built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stk1.<span class="hljs-built_in">top</span>()]) &#123;<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">empty</span>()) &#123;<br>                prefix[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(i + <span class="hljs-number">1</span>) * maxHeights[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prefix[i] = prefix[stk1.<span class="hljs-built_in">top</span>()] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(i - stk1.<span class="hljs-built_in">top</span>()) * maxHeights[i];<br>            &#125;<br>            stk1.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">//处理单调非递增，转为右侧单调非递减</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stk2.<span class="hljs-built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stk2.<span class="hljs-built_in">top</span>()]) &#123;<br>                stk2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>                suffix[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(n - i) * maxHeights[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                suffix[i] = suffix[stk2.<span class="hljs-built_in">top</span>()] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(stk2.<span class="hljs-built_in">top</span>() - i) * maxHeights[i];<br>            &#125;<br>            stk2.<span class="hljs-built_in">push</span>(i);<br>            res = <span class="hljs-built_in">max</span>(res, prefix[i] + suffix[i] - maxHeights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2095</title>
    <link href="/2024/01/25/Leetcode2095/"/>
    <url>/2024/01/25/Leetcode2095/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2095-删除链表的中间节点"><a href="#Leetcode-2095-删除链表的中间节点" class="headerlink" title="Leetcode 2095 - 删除链表的中间节点"></a>Leetcode 2095 - 删除链表的中间节点</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/?envType=study-plan-v2&envId=leetcode-75">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/?envType=study-plan-v2&amp;envId=leetcode-75</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。</p><p>长度为 n 链表的中间节点是从头数起第 ⌊n &#x2F; 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。</p><p>对于 n &#x3D; 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image2095.png" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：head = [1,3,4,7,1,2,6]<br>输出：[1,3,4,1,2,6]<br>解释：<br>上图表示给出的链表。节点的下标分别标注在每个节点的下方。<br>由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。<br>返回结果为移除节点后的新链表<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>快慢指针，看情况要不要在首节点前加前驱节点</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteMiddle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || head -&gt; next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">//快慢指针</span><br>        ListNode* fast = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* slow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-keyword">while</span> (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) &#123;<br>            fast = fast -&gt; next -&gt; next;<br>            slow = slow -&gt; next;<br>        &#125;<br>        slow -&gt; next = slow -&gt; next -&gt; next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2765</title>
    <link href="/2024/01/25/Leetcode2765/"/>
    <url>/2024/01/25/Leetcode2765/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2765-最长交替子数组"><a href="#Leetcode-2765-最长交替子数组" class="headerlink" title="Leetcode 2765 - 最长交替子数组"></a>Leetcode 2765 - 最长交替子数组</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/longest-alternating-subarray/description/">https://leetcode.cn/problems/longest-alternating-subarray/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始的整数数组 nums 。如果 nums 中长度为 m 的子数组 s 满足以下条件，我们称它是一个 交替子数组 ：</p><p>m 大于 1 。<br>s1 &#x3D; s0 + 1 。<br>下标从 0 开始的子数组 s 与数组 [s0, s1, s0, s1,…,s(m-1) % 2] 一样。也就是说，s1 - s0 &#x3D; 1 ，s2 - s1 &#x3D; -1 ，s3 - s2 &#x3D; 1 ，s4 - s3 &#x3D; -1 ，以此类推，直到 s[m - 1] - s[m - 2] &#x3D; (-1)m 。<br>请你返回 nums 中所有 交替 子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。</p><p>子数组是一个数组中一段连续 非空 的元素序列。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：nums = [2,3,4,3,4]<br>输出：4<br>解释：交替子数组有 [3,4] ，[3,4,3] 和 [3,4,3,4] 。最长的子数组为 [3,4,3,4] ，长度为4 。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>双指针<br>交替子数组满足nums[i] - nums[i - 1] &#x3D;&#x3D; 1, nums[i] - nums[i - 2] &#x3D;&#x3D; 0<br>nums[i] - nums[j] &#x3D;&#x3D; (len - 1) % 2</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">alternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//双指针，固定左端</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[r] - nums[l] == (len - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, len);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[r] - nums[r - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    l = r - <span class="hljs-number">1</span>;<br>                    res = <span class="hljs-built_in">max</span>(res, <span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = r;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>程序员转换产品经理问题</title>
    <link href="/2024/01/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BD%AC%E6%8D%A2%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BD%AC%E6%8D%A2%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员转换产品经理问题"><a href="#程序员转换产品经理问题" class="headerlink" title="程序员转换产品经理问题"></a>程序员转换产品经理问题</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p>无<br>###题目大意：<br>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。 由于经费有限，希望能够通过合理的路线安排尽可能的省些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>输入描述：</p><p>城市个数n(1&lt;n&lt;&#x3D;20,包括北京）</p><p>城市间的车票价钱n行n列的矩阵 m[n][n]</p><p>输出描述：</p><p>最小车费花销s</p><p>实例1：</p><p>4</p><p>0 2 6 5</p><p>2 0 4 4</p><p>6 4 0 2</p><p>5 4 2 0</p><p>输出<br>13</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dfs或bfs搜索问题<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] H)</span> &#123;<br>        <span class="hljs-comment">//BFS队列或者DFS递归去遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> H.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cols</span> <span class="hljs-operator">=</span> H[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">managers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//将所有程序员添加到队列，并统计产品经理的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (H[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (H[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    managers++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//上下左右四个方向遍历</span><br>        <span class="hljs-type">int</span>[][] directions = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; managers &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span>[] curr = queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newRow</span> <span class="hljs-operator">=</span> curr[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newCol</span> <span class="hljs-operator">=</span> curr[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span class="hljs-number">0</span> &amp;&amp; newCol &lt; cols &amp;&amp; H[newRow][newCol] == <span class="hljs-number">1</span>) &#123;<br>                        H[newRow][newCol] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 将产品经理转化为程序员</span><br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newRow, newCol&#125;);<br>                        managers--;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            ans++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> managers == <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[][] H=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method(H);<br>        System.out.println(<span class="hljs-string">&quot;question4 result is:&quot;</span>+result);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>过河问题</title>
    <link href="/2024/01/24/%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/24/%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="过河问题"><a href="#过河问题" class="headerlink" title="过河问题"></a>过河问题</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p>无</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有n个人要过河，但是河边只有一艘船；</p><p>船每次最多坐三个人，每个人单独坐船过河的时间为a[i]；</p><p>两个人或者三个人一起坐船时，过河时间为他们所有人中的最长过河时间；</p><p>为了安全起见，要求每次至少有两个人才能过河。</p><p>问最短需要多少时间，才能把所有人送过河。</p><p>输入描述：</p><p>第一行是整数n，表示测试样例格式</p><p>每个测试样例的第一行是一个正整数n，表示参加过河的人数（2&lt;&#x3D;n&lt;100000）</p><p>第二行是n个正整数a[i] (0&lt;a[i]&lt;100000)，表示n个人单独过河的时间；</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">贪心<br>1.两个人或者三个人，取时间最长的<br>2.四个人<br>（1）最短的两个加最长的先过去，最短的两个回来，最短的加次长的过去<br>(a[0] + a[1] + a[3])+ (a[0] + a[1]) + (a[0] + a[1] + a[2]) = a[1] + a[2] + a[3]<br>（2）最短的三个过去，最短的两个回来，最短的两个带最长的过去（和第一种方案一样）<br>综上，四个人只有一个方案<br>3.四个人以上<br>（1）最短的两个带最长的过去，最短的再回来带次长的，依次带过去<br>(a[0] + a[1] + a[n - 1]) = a[n - 1]<br>（2）最短的三个过去，把第三个留在对岸，最短的两个回来，最短的带最长的两个过去，最短的和第三短的回来，每次把最长的两个送到对岸<br>(a[0] + a[1] + a[2]) + (a[0] + a[1]) + (a[0] + a[n - 1] + a[n - 2]) + (a[0] + a[2]) =  2 * a[2] + a[1] + a[n - 1]<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-comment">//一次带一个</span><br>            <span class="hljs-type">int</span> s1 = a[n - <span class="hljs-number">1</span>] + a[n - <span class="hljs-number">2</span>];<br>            <span class="hljs-comment">//两次带两个</span><br>            <span class="hljs-type">int</span> s2 = <span class="hljs-number">2</span> * a[<span class="hljs-number">2</span>] + a[<span class="hljs-number">1</span>] + a[n - <span class="hljs-number">1</span>];<br>            sum += <span class="hljs-built_in">min</span>(a[n - <span class="hljs-number">1</span>] + a[n - <span class="hljs-number">2</span>], <span class="hljs-number">2</span> * a[<span class="hljs-number">2</span>] + a[<span class="hljs-number">1</span>] + a[n - <span class="hljs-number">1</span>]);<br>            n -= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//可能剩3个或者4个人</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) &#123;<br>            sum += a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + a[n - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>            sum += a[<span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            sum += a[<span class="hljs-number">1</span>];<br>        &#125;<br>        cout&lt;&lt;sum&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode3012</title>
    <link href="/2024/01/22/Leetcode3012/"/>
    <url>/2024/01/22/Leetcode3012/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-3012-通过操作使数组长度最小"><a href="#Leetcode-3012-通过操作使数组长度最小" class="headerlink" title="Leetcode 3012 - 通过操作使数组长度最小"></a>Leetcode 3012 - 通过操作使数组长度最小</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/minimize-length-of-array-using-operations/description/">https://leetcode.cn/problems/minimize-length-of-array-using-operations/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始的整数数组 nums ，它只包含 正 整数。</p><p>你的任务是通过进行以下操作 任意次 （可以是 0 次） 最小化 nums 的长度：</p><p>在 nums 中选择 两个不同 的下标 i 和 j ，满足 nums[i] &gt; 0 且 nums[j] &gt; 0 。<br>将结果 nums[i] % nums[j] 插入 nums 的结尾。<br>将 nums 中下标为 i 和 j 的元素删除。<br>请你返回一个整数，它表示进行任意次操作以后 nums 的 最小长度 。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">考虑这个例子：nums=[2,3,4,5,6]，每次操作都可以选择 2和另一个数字 x，由于 x&gt;2，所以 2 mod x=2 ，于是操作等价于：移除x<br>如果数组中最小值只有一个，返回1<br>不止一个，也能构造出小于当前最小值m的值，返回1，除非所有的数都是m的倍数，那么先清除m之外的元素，返回的是(m + 1)/2<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumArrayLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = *<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x % m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (ranges::<span class="hljs-built_in">count</span>(nums,m) + <span class="hljs-number">1</span>)/ <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2736</title>
    <link href="/2024/01/22/Leetcode2736/"/>
    <url>/2024/01/22/Leetcode2736/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2736-最大和查询"><a href="#Leetcode-2736-最大和查询" class="headerlink" title="Leetcode 2736 - 最大和查询"></a>Leetcode 2736 - 最大和查询</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/maximum-sum-queries/description/">https://leetcode.cn/problems/maximum-sum-queries/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你两个长度为 n 、下标从 0 开始的整数数组 nums1 和 nums2 ，另给你一个下标从 1 开始的二维数组 queries ，其中 queries[i] &#x3D; [xi, yi] 。</p><p>对于第 i 个查询，在所有满足 nums1[j] &gt;&#x3D; xi 且 nums2[j] &gt;&#x3D; yi 的下标 j (0 &lt;&#x3D; j &lt; n) 中，找出 nums1[j] + nums2[j] 的 最大值 ，如果不存在满足条件的 j 则返回 -1 。</p><p>返回数组 answer ，其中 answer[i] 是第 i 个查询的答案。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">单调栈+二分查找<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maximumSumQueries</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; sortedNums;<br>        vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; sortedQueries;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sortedNums.<span class="hljs-built_in">emplace_back</span>(nums1[i], nums2[i]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(sortedNums.<span class="hljs-built_in">begin</span>(), sortedNums.<span class="hljs-built_in">end</span>(), greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sortedQueries.<span class="hljs-built_in">emplace_back</span>(i, queries[i][<span class="hljs-number">0</span>], queries[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(sortedQueries.<span class="hljs-built_in">begin</span>(), sortedQueries.<span class="hljs-built_in">end</span>(), [](tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a) &gt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>        &#125;);<br><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stk;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(queries.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[i, x, y] : sortedQueries) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; sortedNums.<span class="hljs-built_in">size</span>() &amp;&amp; sortedNums[j].first &gt;= x) &#123;<br>                <span class="hljs-keyword">auto</span> [num1, num2] = sortedNums[j];<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">back</span>().second &lt;= num1 + num2) &#123;<br>                    stk.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">back</span>().first &lt; num2) &#123;<br>                    stk.<span class="hljs-built_in">emplace_back</span>(num2, num1 + num2);<br>                &#125;<br>                j++;<br>            &#125;<br>            <span class="hljs-type">int</span> k = <span class="hljs-built_in">lower_bound</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">make_pair</span>(y, <span class="hljs-number">0</span>)) - stk.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">if</span> (k &lt; stk.<span class="hljs-built_in">size</span>()) &#123;<br>                answer[i] = stk[k].second;<br>            &#125;<br>        &#125;    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stk.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            cout &lt;&lt; stk[i].first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; stk[i].second &lt;&lt; endl;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2352</title>
    <link href="/2024/01/22/Leetcode2352/"/>
    <url>/2024/01/22/Leetcode2352/</url>
    
    <content type="html"><![CDATA[<p>#Leetcode 2352 - 相等行列对</p><p>###题目链接：<br><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/description/">https://leetcode.cn/problems/equal-row-and-column-pairs/description/</a><br>###题目大意：<br>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">方法一：哈希表存一行vector&lt;int&gt;，遍历列的时候再求数目。<br>方法二：方法一的基础上，一行存为字符串<span class="hljs-built_in">hash</span>,str = str * 13 + x<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">equalPairs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">//字符串hash</span><br>        unordered_map&lt;ULL, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : grid) &#123;<br>            ULL str = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : row) &#123;<br>                str = str * <span class="hljs-number">131</span> + x;<br>            &#125;<br>            hash[str]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            ULL str = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                str = str * <span class="hljs-number">131</span> + grid[i][j];<br>            &#125;<br>            ans += hash[str];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode649</title>
    <link href="/2024/01/22/Leetcode649/"/>
    <url>/2024/01/22/Leetcode649/</url>
    
    <content type="html"><![CDATA[<p>#Leetcode 649 - Dota2参议院</p><p>###题目链接：<br><a href="https://leetcode.cn/problems/dota2-senate/description/">https://leetcode.cn/problems/dota2-senate/description/</a><br>###题目大意：<br>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：</p><p>禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。<br>宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。<br>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">RDRRDDDDDRR<br>10110011100<br>00110000100<br>00010000000<br>贪心，按次ban，折半遍历O(n * logn)<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">predictPartyVictory</span><span class="hljs-params">(string senate)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = senate.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt_R = <span class="hljs-number">0</span>, cnt_D = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> live_R = <span class="hljs-number">0</span>, live_D = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//记录存活状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">state</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : senate) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                live_R++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                live_D++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (live_R != <span class="hljs-number">0</span> &amp;&amp; live_D != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (state[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (senate[i] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123; <span class="hljs-comment">//下一个投票的是R且他存活</span><br>                        <span class="hljs-keyword">if</span> (cnt_D &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//被前面ban</span><br>                            state[i] = <span class="hljs-literal">false</span>;<br>                            live_R--;<br>                            cnt_D--;<br>                        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//未被前面ban</span><br>                            cnt_R++;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//下一个投票的是D且他存活</span><br>                        <span class="hljs-keyword">if</span> (cnt_R &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//被前面ban</span><br>                            state[i] = <span class="hljs-literal">false</span>;<br>                            live_D--;<br>                            cnt_R--;<br>                        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//未被前面ban</span><br>                            cnt_D++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> live_R &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;Radiant&quot;</span> : <span class="hljs-string">&quot;Dire&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode82</title>
    <link href="/2024/01/22/Leetcode82/"/>
    <url>/2024/01/22/Leetcode82/</url>
    
    <content type="html"><![CDATA[<p>#Leetcode 82 - 删除排序链表中的重复元素 II</p><p>###题目链接：<br><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a><br>###题目大意：<br>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br>示例1:<br><img src="/image82.png" alt="Alt text"><br>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">遍历每一个节点，如果这个节点的下一节点值和下下一节点值相同，将下一节点值当作判断值，进入循环，删除下一节点以及后续相同值节点。<br>由于首节点有可能被删除，新建一个前驱节点，返回pre-&gt;next<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* cur = pre;<br>        <span class="hljs-keyword">while</span> (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; next) &#123;<br>            <span class="hljs-keyword">if</span> (cur -&gt; next -&gt; val == cur -&gt; next -&gt; next -&gt; val) &#123;<br>                <span class="hljs-type">int</span> t = cur -&gt; next -&gt; val;<br>                <span class="hljs-keyword">while</span> (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val == t) &#123;<br>                    cur -&gt; next = cur -&gt; next -&gt; next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur -&gt; next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TSP</title>
    <link href="/2024/01/22/TSP/"/>
    <url>/2024/01/22/TSP/</url>
    
    <content type="html"><![CDATA[<p>#TSP - Traveling Salesman Problem</p><p>###题目链接：<br>无<br>###题目大意：<br>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。<br>由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>输入描述:<br>第一个入参H[N][N]：表示H城市间的车票价钱N行N列的矩阵，N表示城市个数(1&lt;n≤20，包括北京)</p><p>输出描述:<br>最小车费花销s</p><p>说明<br>共4 个城市，城市1 和城市 1 的车费为0，城市 1 和城市 2之间的车费为 2，城市 1 和城市3之间的车费为 6，城市 1和城市 4 之间的车费为5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">旅行商问题，组合优化中的一个NP完全问题，带权无向图求最大最小权值，动态规划+状态压缩<br>当数量规模过大时，dp解决的效率不如采用近似算法或神经算法等<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] H)</span>&#123;<br>    <span class="hljs-comment">//内部逻辑由参赛老师自行实现</span><br>    <span class="hljs-comment">//题目缺失关键信息，第一个城市应该是北京吧</span><br>    <span class="hljs-comment">//dp[state][city]表示在state状态下，位于city城市的最小花销</span><br>    <span class="hljs-comment">//dp[state][i] = Math.min(dp[state][j], dp[state ^ (1 &lt;&lt; j)][i] + H[i][j]);</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> H.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">states</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; <span class="hljs-comment">//用二进制表示城市访问状态</span><br>    <span class="hljs-comment">//初始化dp</span><br>    <span class="hljs-type">int</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; n][n];<br>    <span class="hljs-comment">//设置初始值且避免整数溢出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>        Arrays.fill(dp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-comment">//初始状态，dp[0001][0] = 0</span><br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; state &lt;= states; state++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//上一个访问的城市和上一次访问后的state对应值需要一致</span><br>            <span class="hljs-keyword">if</span> ((state &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-comment">//上一次访问城市和下一次访问城市不用，且下一个访问的城市在访问后的state对应值需要一致</span><br>                    <span class="hljs-keyword">if</span> (i != j &amp;&amp; (state &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                        dp[state][j] = Math.min(dp[state][j], dp[state ^ (<span class="hljs-number">1</span> &lt;&lt; j)][i] + H[i][j]);<br>                        <span class="hljs-comment">//System.out.println((state ^ (1 &lt;&lt; j)) + &quot; &quot; + state + &quot; &quot; + i + &quot; &quot; + j + &quot; &quot; + dp[state][j]);</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-comment">//求最后一个城市返回0的最小花销</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        result = Math.min(result, dp[states][i] + H[i][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span>[][] H=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method(H);<br>    System.out.println(<span class="hljs-string">&quot;question2 result is:&quot;</span>+result);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ideal</title>
    <link href="/2024/01/17/ideal/"/>
    <url>/2024/01/17/ideal/</url>
    
    <content type="html"><![CDATA[<h1 id="Ideal"><a href="#Ideal" class="headerlink" title="Ideal"></a>Ideal</h1><h3 id="1-启动失败"><a href="#1-启动失败" class="headerlink" title="1.启动失败"></a>1.启动失败</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">报错内容：No active profile <span class="hljs-built_in">set</span>, falling back to default profiles: default<br>原因：23年版ideal默认隐藏VM options，有的项目通过Program arguments配置环境变量，有的通过VM options，填错就会找不到配置环境<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2024/01/15/Linux/"/>
    <url>/2024/01/15/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="1-修改用户密码"><a href="#1-修改用户密码" class="headerlink" title="1.修改用户密码"></a>1.修改用户密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ passwd //修改当前用户密码<br>$ sudo passwd [用户名] //修改指定用户密码<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>how to use kindle</title>
    <link href="/2024/01/13/how-to-use-kindle/"/>
    <url>/2024/01/13/how-to-use-kindle/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用总结"><a href="#Hexo使用总结" class="headerlink" title="Hexo使用总结"></a>Hexo使用总结</h1><h2 id="1-如何传文件到Kindle"><a href="#1-如何传文件到Kindle" class="headerlink" title="1.如何传文件到Kindle"></a>1.如何传文件到Kindle</h2><h5 id="（1）设备本地"><a href="#（1）设备本地" class="headerlink" title="（1）设备本地"></a>（1）设备本地</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">数据线直连Kindle传<br></code></pre></td></tr></table></figure><h5 id="（2）云图书馆（推荐，各设备可同步进度）"><a href="#（2）云图书馆（推荐，各设备可同步进度）" class="headerlink" title="（2）云图书馆（推荐，各设备可同步进度）"></a>（2）云图书馆（推荐，各设备可同步进度）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过微信传输文件，将文本（txt等格式文件）传至手机微信<br>微信点击文件，用其他应用打开，选择Kindle手机app打开<br>修改文件后缀，加上【.mobi】传至Kindle云图书馆，设备同步数据即可看到电子书<br></code></pre></td></tr></table></figure><h2 id="2-如何使用Kindle"><a href="#2-如何使用Kindle" class="headerlink" title="2.如何使用Kindle"></a>2.如何使用Kindle</h2><h5 id="（1）退出阅读模式"><a href="#（1）退出阅读模式" class="headerlink" title="（1）退出阅读模式"></a>（1）退出阅读模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">点击电子书上方即可弹出bar<br></code></pre></td></tr></table></figure><h5 id="（2）云图书馆（推荐，各设备可同步进度）-1"><a href="#（2）云图书馆（推荐，各设备可同步进度）-1" class="headerlink" title="（2）云图书馆（推荐，各设备可同步进度）"></a>（2）云图书馆（推荐，各设备可同步进度）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过微信传输文件，将文本（txt等格式文件）传至手机微信<br>微信点击文件，用其他应用打开，选择Kindle手机app打开<br>修改文件后缀，加上【.mobi】传至Kindle云图书馆，设备同步数据即可看到电子书<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2645</title>
    <link href="/2024/01/12/Leetcode2645/"/>
    <url>/2024/01/12/Leetcode2645/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2645-构造有效字符串的最小插入数"><a href="#Leetcode-2645-构造有效字符串的最小插入数" class="headerlink" title="Leetcode 2645 - 构造有效字符串的最小插入数"></a>Leetcode 2645 - 构造有效字符串的最小插入数</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/description/">https://leetcode.cn/problems/minimum-additions-to-make-valid-string/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个字符串 word ，你可以向其中任何位置插入 “a”、”b” 或 “c” 任意次，返回使 word 有效 需要插入的最少字母数。<br>如果字符串可以由 “abc” 串联多次得到，则认为该字符串 有效 。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">动态规划：<br>1.word[i] 单独存在于一组 abc 中，dp[i] = dp[i - 1] + 2<br>2.如果word[i] &gt; word[i - 1]，则word[i]和word[i - 1]在同一组中，那么 dp[i] = dp[i - 1] - 1<br>例子：<br>abcbabbc<br>021024354<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(string word)</span> </span>&#123;s<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (word[i] &gt; word[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>transform2Json</title>
    <link href="/2024/01/12/transform2Json/"/>
    <url>/2024/01/12/transform2Json/</url>
    
    <content type="html"><![CDATA[<p>#报文转Json格式<br><!DOCTYPE html></p><html lang="en"><head>    <title>        json格式化    </title>    <meta charset="UTF-8"></head><script type="text/javascript">    function initStyle() {        document.body.style.width = window.innerWidth;        document.getElementById("output_value").style.height = window.innerHeight + "px";    }</script><body onload="initStyle()">    <textarea id="content_value" style="width: 100%;height:150px;"></textarea>    <div style="width: 100%;text-align: center;">        <input type="button" value="格式化" onclick="check()">    </div>    <textarea id="output_value" style="width: 100%;"></textarea></body><script type="text/javascript">    function check() {        var text_value = document.getElementById("content_value").value;        if (text_value == "") {            alert("不能为空");            return false;        } else {            var res = "";            for (var i = 0, j = 0, k = 0, ii, ele; i < text_value.length; i++) {                //k:缩进 j:个数                ele = text_value.charAt(i);                if (j % 2 == 0 && (ele == "}" || ele == "]")) {                    k--;                    for (ii = 0; ii < k; ii++) {                        ele = "\t" + ele;                    }                    ele = "\n" + ele;                } else if (j % 2 == 0 && (ele == "{" || ele == "[")) {                    ele += "\n";                    k++;                    for (ii = 0; ii < k; ii++) {                        ele += "\t";                    }                } else if (j % 2 == 0 && ele == ",") {                    ele += "\n";                     for (ii = 0; ii < k; ii++) {                        ele += "\t";                    }                } else if (ele == "\"") {                    j++;                }                res += ele;            }            document.getElementById("output_value").value = res;        }    }</script></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2024/01/12/hexo/"/>
    <url>/2024/01/12/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用总结"><a href="#Hexo使用总结" class="headerlink" title="Hexo使用总结"></a>Hexo使用总结</h1><h2 id="1-如何更换主题"><a href="#1-如何更换主题" class="headerlink" title="1.如何更换主题"></a>1.如何更换主题</h2><h5 id="（1）hexo根目录下"><a href="#（1）hexo根目录下" class="headerlink" title="（1）hexo根目录下"></a>（1）hexo根目录下</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br>$ <span class="hljs-built_in">cd</span> fluid<br>$ npm install<br></code></pre></td></tr></table></figure><h5 id="（2）修改Hexo根目录下-config-yml"><a href="#（2）修改Hexo根目录下-config-yml" class="headerlink" title="（2）修改Hexo根目录下_config.yml"></a>（2）修改Hexo根目录下_config.yml</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid<br></code></pre></td></tr></table></figure><h5 id="（3）清除缓存"><a href="#（3）清除缓存" class="headerlink" title="（3）清除缓存"></a>（3）清除缓存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h5 id="（4）构建页面"><a href="#（4）构建页面" class="headerlink" title="（4）构建页面"></a>（4）构建页面</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><h5 id="（5）本地调试"><a href="#（5）本地调试" class="headerlink" title="（5）本地调试"></a>（5）本地调试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><h5 id="（6）上传版本（版本更新大概需要2min）"><a href="#（6）上传版本（版本更新大概需要2min）" class="headerlink" title="（6）上传版本（版本更新大概需要2min）"></a>（6）上传版本（版本更新大概需要2min）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><h5 id="如果报错：无权限或者文件不存在，检查是否有权限上传-key-或-config-yml文件配置是否正确"><a href="#如果报错：无权限或者文件不存在，检查是否有权限上传-key-或-config-yml文件配置是否正确" class="headerlink" title="如果报错：无权限或者文件不存在，检查是否有权限上传(key)或_config.yml文件配置是否正确"></a>如果报错：无权限或者文件不存在，检查是否有权限上传(key)或_config.yml文件配置是否正确</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:hide-in-bed/blog.git<br>  branch: master<br></code></pre></td></tr></table></figure><h5 id="如果报错：ssh-connect-to-host-github-com-port-22-Connection-timed-out"><a href="#如果报错：ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="headerlink" title="如果报错：ssh: connect to host github.com port 22: Connection timed out"></a>如果报错：ssh: connect to host github.com port 22: Connection timed out</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:hide-in-bed/blog.git<br>  branch: master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/10/hello-world/"/>
    <url>/2024/01/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
