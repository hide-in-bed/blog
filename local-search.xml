<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode450</title>
    <link href="/2024/02/06/LeetCode450/"/>
    <url>/2024/02/06/LeetCode450/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-450-删除二叉搜索树中的节点"><a href="#Leetcode-450-删除二叉搜索树中的节点" class="headerlink" title="Leetcode 450 - 删除二叉搜索树中的节点"></a>Leetcode 450 - 删除二叉搜索树中的节点</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">https://leetcode.cn/problems/delete-node-in-a-bst/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image450.jpg" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>见官方题解</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root -&gt; val &gt; key) &#123;<br>            root -&gt; left = <span class="hljs-built_in">deleteNode</span>(root -&gt; left, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root -&gt; val &lt; key) &#123;<br>            root -&gt; right = <span class="hljs-built_in">deleteNode</span>(root -&gt; right, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root -&gt; val == key) &#123;<br>            <span class="hljs-keyword">if</span> (!root -&gt; left &amp;&amp; !root -&gt; right) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!root -&gt; left) &#123;<br>                <span class="hljs-keyword">return</span> root -&gt; right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!root -&gt; right) &#123;<br>                <span class="hljs-keyword">return</span> root -&gt; left;<br>            &#125;<br>            TreeNode* t = root -&gt; right;<br>            <span class="hljs-keyword">while</span> (t -&gt; left) &#123;<br>                t = t -&gt; left;<br>            &#125;<br>            root -&gt; right = <span class="hljs-built_in">deleteNode</span>(root -&gt; right, t -&gt; val);<br>            t -&gt; left = root -&gt; left;<br>            t -&gt; right = root -&gt; right;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2808</title>
    <link href="/2024/02/06/LeetCode2808/"/>
    <url>/2024/02/06/LeetCode2808/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2808-使循环数组所有元素相等的最少秒数"><a href="#Leetcode-2808-使循环数组所有元素相等的最少秒数" class="headerlink" title="Leetcode 2808 - 使循环数组所有元素相等的最少秒数"></a>Leetcode 2808 - 使循环数组所有元素相等的最少秒数</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/description/">https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始长度为 n 的数组 nums 。</p><p>每一秒，你可以对数组执行以下操作：</p><p>对于范围在 [0, n - 1] 内的每一个下标 i ，将 nums[i] 替换成 nums[i] ，nums[(i - 1 + n) % n] 或者 nums[(i + 1) % n] 三者之一。<br>注意，所有元素会被同时替换。</p><p>请你返回将数组 nums 中所有元素变成相等元素所需要的 最少 秒数。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：nums = [1,2,1,2]<br>输出：1<br>解释：我们可以在 1 秒内将数组变成相等元素：<br>- 第 1 秒，将每个位置的元素分别变为 [nums[3],nums[1],nums[3],nums[3]] 。变化后，nums = [2,2,2,2] 。<br>1 秒是将数组变成相等元素所需要的最少秒数。 <br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>相同元素间的最大距离即变成该元素的最少秒数<br>用哈希表存某元素的所在位置</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumSeconds</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//相同元素间的最大距离即变成该元素的最少秒数</span><br>        <span class="hljs-comment">//用哈希表存某元素的所在位置</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; hp;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hp[nums[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-type">int</span> res = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : hp) &#123;<br>            <span class="hljs-type">int</span> len = it.second[<span class="hljs-number">0</span>] + n - it.second.<span class="hljs-built_in">back</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; it.second.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                len = <span class="hljs-built_in">max</span>(len, it.second[i] - it.second[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//找出最长距离最短的元素的秒数</span><br>            res = <span class="hljs-built_in">min</span>(res, len / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode236</title>
    <link href="/2024/02/06/LeetCode236/"/>
    <url>/2024/02/06/LeetCode236/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-236-二叉树的最近公共祖先"><a href="#Leetcode-236-二叉树的最近公共祖先" class="headerlink" title="Leetcode 236 - 二叉树的最近公共祖先"></a>Leetcode 236 - 二叉树的最近公共祖先</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image236.png" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><img src="/image236_2.png" alt="Alt text"></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root -&gt; right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode42</title>
    <link href="/2024/02/06/LeetCode42/"/>
    <url>/2024/02/06/LeetCode42/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-42-接雨水"><a href="#Leetcode-42-接雨水" class="headerlink" title="Leetcode 42 - 接雨水"></a>Leetcode 42 - 接雨水</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image42.png" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>双指针<br>从左往右能到达的最大高度，和从右往左能到达的最大高度，取较小值</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-comment">//从左往右能到达的最大高度，和从右往左能到达的最大高度，取较小值</span><br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            leftMax = <span class="hljs-built_in">max</span>(leftMax, height[left]);<br>            rightMax = <span class="hljs-built_in">max</span>(rightMax, height[right]);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                res += leftMax - height[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += rightMax -height[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode437</title>
    <link href="/2024/02/06/LeetCode437/"/>
    <url>/2024/02/06/LeetCode437/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-437-路径总和III"><a href="#Leetcode-437-路径总和III" class="headerlink" title="Leetcode 437 - 路径总和III"></a>Leetcode 437 - 路径总和III</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/path-sum-iii/description/">https://leetcode.cn/problems/path-sum-iii/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。<br>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image437.jpg" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>深度优先遍历，满足条件的数目&#x3D;根节点为初始节点的路径数目<br>+左子节点为初始节点的路径数目<br>+右子节点为初始节点的路径数目</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">//以每个节点作为头结点</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, targetSum) + <span class="hljs-built_in">pathSum</span>(root -&gt; left, targetSum) + <span class="hljs-built_in">pathSum</span>(root -&gt; right, targetSum);<br>    &#125;<br><br>    <span class="hljs-comment">//头结点的路径满足target的数目</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root -&gt; val == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">dfs</span>(root -&gt; left, <span class="hljs-number">0</span>) + <span class="hljs-built_in">dfs</span>(root -&gt; right, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root -&gt; left, target - root -&gt; val) + <span class="hljs-built_in">dfs</span>(root -&gt; right, target - root -&gt; val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2130</title>
    <link href="/2024/02/06/LeetCode2130/"/>
    <url>/2024/02/06/LeetCode2130/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2130-链表最大孪生和"><a href="#Leetcode-2130-链表最大孪生和" class="headerlink" title="Leetcode 2130 - 链表最大孪生和"></a>Leetcode 2130 - 链表最大孪生和</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/description/">https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;&#x3D; i &lt;&#x3D; (n &#x2F; 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。<br>比方说，n &#x3D; 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n &#x3D; 4 的链表中所有的孪生节点。<br>孪生和 定义为一个节点和它孪生节点两者值之和。<br>给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image2130.png" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：head = [5,4,2,1]<br>输出：6<br>解释：<br>节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。<br>链表中没有其他孪生节点。<br>所以，链表的最大孪生和是 6 。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>快慢指针+翻转链表<br>翻转后半段，孪生和变成a[i] + a[n&#x2F;2+i]</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//快慢指针+翻转链表</span><br>    <span class="hljs-comment">//fast指向最后一个节点时，slow的下一个节点指向后半段的开始节点</span><br>    <span class="hljs-comment">//翻转后半段，孪生和变成a[i] + a[n/2+i]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pairSum</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* slow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-keyword">while</span> (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) &#123;<br>            fast = fast -&gt; next -&gt; next;<br>            slow = slow -&gt; next;<br>        &#125;<br>        <span class="hljs-comment">//返回节点的头结点</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//翻转的节点</span><br>        ListNode* cur = slow -&gt; next;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode* aft = cur -&gt; next; <span class="hljs-comment">//建一个后驱节点保存下一次翻转000的节点</span><br>            cur -&gt; next = pre;<br>            pre = cur;<br>            cur = aft;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        ListNode* x = head;<br>        ListNode* y = pre;<br>        <span class="hljs-keyword">while</span> (y) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, x -&gt; val + y -&gt; val);<br>            x = x -&gt; next;<br>            y = y -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode670</title>
    <link href="/2024/02/05/LeetCode670/"/>
    <url>/2024/02/05/LeetCode670/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-670-最大交换"><a href="#Leetcode-670-最大交换" class="headerlink" title="Leetcode 670 - 最大交换"></a>Leetcode 670 - 最大交换</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/maximum-swap/description/">https://leetcode.cn/problems/maximum-swap/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。</p><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入: <span class="hljs-number">2736</span><br>输出: <span class="hljs-number">7236</span><br>解释: 交换数字<span class="hljs-number">2</span>和数字<span class="hljs-number">7</span>。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">贪心，将最大的数字移动到前面，如果前面本身是最大数字，则不动<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">//贪心，将最大的数字移动到前面，如果前面本身是最大数字，则不动</span><br>        string numString = <span class="hljs-built_in">to_string</span>(num);<br>        <span class="hljs-type">int</span> n = numString.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-built_in">maxIndex</span>(numString, i);<br>            <span class="hljs-keyword">if</span> (numString[maxValueIndex] != numString[i]) &#123;<br>                <span class="hljs-built_in">swap</span>(numString[i], numString[maxValueIndex]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans *= <span class="hljs-number">10</span>;<br>            ans += numString[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxIndex</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-comment">//从后往前寻找最大值</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= start; i--) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] - <span class="hljs-string">&#x27;0&#x27;</span> &gt; max) &#123;<br>                max = str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ans = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode总结</title>
    <link href="/2024/02/03/LeetCode%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/03/LeetCode%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h3><h3 id="3-双指针"><a href="#3-双指针" class="headerlink" title="3.双指针"></a>3.双指针</h3><h3 id="4-滑动窗口"><a href="#4-滑动窗口" class="headerlink" title="4.滑动窗口"></a>4.滑动窗口</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>binarySearch</title>
    <link href="/2024/02/03/binarySearch/"/>
    <url>/2024/02/03/binarySearch/</url>
    
    <content type="html"><![CDATA[<h1 id="1-二分查找的一些特殊情况"><a href="#1-二分查找的一些特殊情况" class="headerlink" title="1.二分查找的一些特殊情况"></a>1.二分查找的一些特殊情况</h1><p>（1）求&gt;&#x3D;时会存在取不到数组右侧的情况，这个时候初始化r &#x3D; n(n代表数组长度)可以解决<br>同理&lt;&#x3D;时会存在取不到数组左侧的情况，这个时候初始化l &#x3D; -1(n代表数组长度)可以解决<br>参考：<a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/">Leetcode2300.咒语和药水的成功对数</a></p><h1 id="2-二分查找的有趣题目"><a href="#2-二分查找的有趣题目" class="headerlink" title="2.二分查找的有趣题目"></a>2.二分查找的有趣题目</h1><p>（1）<a href="https://leetcode.cn/problems/find-peak-element/?envType=study-plan-v2&envId=leetcode-75">Leetcode162.寻找峰值</a><br>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = (r - l) / <span class="hljs-number">2</span> + l;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode3020</title>
    <link href="/2024/01/31/Leetcode3020/"/>
    <url>/2024/01/31/Leetcode3020/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-3020-子集中元素的最大数量"><a href="#Leetcode-3020-子集中元素的最大数量" class="headerlink" title="Leetcode 3020 - 子集中元素的最大数量"></a>Leetcode 3020 - 子集中元素的最大数量</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/description/">https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个 正整数 数组 nums 。</p><p>你需要从数组中选出一个满足下述条件的<br>子集<br>：</p><p>你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：[x, x2, x4, …, xk&#x2F;2, xk, xk&#x2F;2, …, x4, x2, x]（注意，k 可以是任何 非负 的 2 的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。<br>返回满足这些条件的子集中，元素数量的 最大值 。</p><p>示例 1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：nums = [5,4,1,2,2]<br>输出：3<br>解释：选择子集 &#123;4,2,2&#125; ，将其放在数组 [2,4,2] 中，它遵循该模式，且 22 == 4 。因此答案是 3 。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">固定数组中间值，确定一个数组，然后用哈希表来判断能否成立。但是超时。<br>本题数据规模p最大为4，因此可以采用暴力。暴力反而不会超时。<br>注意特判 x=1 的情况。<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//此解答超时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//固定数组中间值，确定一个数组</span><br>        <span class="hljs-comment">//哈希表用来后续求子集元素数量</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            hashmap[num]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> h : hashmap) &#123;<br>            hashmap[h.first]--;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">subsetCount</span>(h.first, hashmap));<br>            hashmap[h.first]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subsetCount</span><span class="hljs-params">(<span class="hljs-type">int</span> num, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> hp[<span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? hp[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> : hp[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (num) &#123;<br>            <span class="hljs-type">double</span> dt = <span class="hljs-built_in">sqrt</span>(num);<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">floor</span>(dt);<br>            <span class="hljs-keyword">if</span> (t * t != num || hp[t] &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res += <span class="hljs-number">2</span>;<br>            num = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//暴力求解反而可以通过</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; hp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            hp[num]++;<br>        &#125;<br>        <span class="hljs-comment">//特例x==1</span><br>        <span class="hljs-type">int</span> ans = hp[<span class="hljs-number">1</span>] - (hp[<span class="hljs-number">1</span>] % <span class="hljs-number">2</span> ^ <span class="hljs-number">1</span>);<br>        hp.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[num, _] : hp) &#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = num;<br>            cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-comment">//这里不能省略hp.contains(x)，因为x*=x会改变hp[x]</span><br>            <span class="hljs-keyword">for</span> (; hp.<span class="hljs-built_in">contains</span>(x) &amp;&amp; hp[x] &gt; <span class="hljs-number">1</span>; x *= x) &#123;<br>                res += <span class="hljs-number">2</span>; <br>            &#125;<br>            res += hp.<span class="hljs-built_in">contains</span>(x) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            ans = <span class="hljs-built_in">max</span>(ans, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2024/01/31/C++/"/>
    <url>/2024/01/31/C++/</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习记录"><a href="#C-学习记录" class="headerlink" title="C++学习记录"></a>C++学习记录</h1><h3 id="1-值传递和引用传递"><a href="#1-值传递和引用传递" class="headerlink" title="1.值传递和引用传递"></a>1.值传递和引用传递</h3><p>值传递：传值，形参有自己的存储空间，对形参的改变不会改变实参值，效率低于引用传递<br>引用传递：传的是地址，不分配新的内存空间，方对形参的改变会改变实参值<br><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">Leetcode1466</a>值传递超时，因为值传递会拷贝一次实参，有时间开销</p><h3 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2.匿名函数"></a>2.匿名函数</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sort(a, a + <span class="hljs-number">4</span>, [=](<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) -&gt; <span class="hljs-built_in">bool</span> &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">10</span> &lt; y % <span class="hljs-number">10</span>; &#125; );<br></code></pre></td></tr></table></figure><h3 id="3-a-b向上取整"><a href="#3-a-b向上取整" class="headerlink" title="3.a&#x2F;b向上取整"></a>3.a&#x2F;b向上取整</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">（a + b - <span class="hljs-number">1</span>) / b<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-Annotation</title>
    <link href="/2024/01/30/Java-Annotation/"/>
    <url>/2024/01/30/Java-Annotation/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h1><h2 id="1-Override和-Authwired和-Resource"><a href="#1-Override和-Authwired和-Resource" class="headerlink" title="1.@Override和@Authwired和@Resource"></a>1.@Override和@Authwired和@Resource</h2><p>（1）@Override注解是伪代码，表示子类重写父类的方法<br>（2）@Authwired和@Resource区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">区别：@Autowired跟Spring框架强耦合了，如果换成其他框架，@Autowired就没作用了。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持<br>包含的属性：@Autowired只包含一个参数：required，表示是否开启自动注入，默认是<span class="hljs-literal">true</span>。而@Resource包含七个参数，其中最重要的两个参数是：name 和 <span class="hljs-built_in">type</span><br>装配规则：Autowired默认按byType自动装配，而@Resource默认byName自动装配<br>注解应用的地方不同：@Autowired能够用在：构造器、方法、参数、成员变量和注解上<br>@Resource能用在：类、成员变量和方法上<br>什么时候用：Autowired按类型查找，书写方便，不用在后面跟名字，缺点：当一个Service有多个ServiceImpl去实现时，那么会报错，因为它不知道去实现哪一个。Resource按名字查找，后面要跟参数name，好处：当有多个Impl实现类时，可以通name快速找到<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode206</title>
    <link href="/2024/01/26/Leetcode206/"/>
    <url>/2024/01/26/Leetcode206/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-206-翻转链表"><a href="#Leetcode-206-翻转链表" class="headerlink" title="Leetcode 206 - 翻转链表"></a>Leetcode 206 - 翻转链表</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image206.png" alt="Alt text"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>迭代和递归都可以解决，迭代逻辑上更好理解，假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode* aft = cur -&gt; next;<br>            cur -&gt; next = pre;<br>            pre = cur;<br>            cur = aft;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode328</title>
    <link href="/2024/01/26/Leetcode328/"/>
    <url>/2024/01/26/Leetcode328/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-328-奇偶链表"><a href="#Leetcode-328-奇偶链表" class="headerlink" title="Leetcode 328 - 奇偶链表"></a>Leetcode 328 - 奇偶链表</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/odd-even-linked-list/description/">https://leetcode.cn/problems/odd-even-linked-list/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。<br>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。<br>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。<br>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image328.png" alt="Alt text"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <span class="hljs-built_in">head</span> = [1,2,3,4,5]<br>输出: [1,3,5,2,4]<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>题目要求O(1)的空间复杂度，则只能用链表这个数据结构去解决问题，新建节点在原链表上处理</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* evenHead = head -&gt; next;<br>        ListNode* odd = head;<br>        ListNode* even = evenHead;<br>        <span class="hljs-keyword">while</span> (even &amp;&amp; even -&gt; next) &#123;<br>            odd -&gt; next = even -&gt; next;<br>            odd = odd -&gt; next;<br>            even -&gt; next = odd -&gt; next;<br>            even = even -&gt; next;<br>        &#125;<br>        odd -&gt; next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2865</title>
    <link href="/2024/01/26/Leetcode2865/"/>
    <url>/2024/01/26/Leetcode2865/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2865-美丽塔I"><a href="#Leetcode-2865-美丽塔I" class="headerlink" title="Leetcode 2865 - 美丽塔I"></a>Leetcode 2865 - 美丽塔I</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/beautiful-towers-i/description/">https://leetcode.cn/problems/beautiful-towers-i/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个长度为 n 下标从 0 开始的整数数组 maxHeights 。<br>你的任务是在坐标轴上建 n 座塔。第 i 座塔的下标为 i ，高度为 heights[i] 。<br>如果以下条件满足，我们称这些塔是 美丽 的：<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]<br>heights 是一个 山脉 数组。<br>如果存在下标 i 满足以下条件，那么我们称数组 heights 是一个 山脉 数组：<br>对于所有 0 &lt; j &lt;&#x3D; i ，都有 heights[j - 1] &lt;&#x3D; heights[j]<br>对于所有 i &lt;&#x3D; k &lt; n - 1 ，都有 heights[k + 1] &lt;&#x3D; heights[k]<br>请你返回满足 美丽塔 要求的方案中，高度和的最大值 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：maxHeights = [5,3,4,1,1]<br>输出：13<br>解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：<br>- 1 &lt;= heights[i] &lt;= maxHeights[i]  <br>- heights 是个山脉数组，峰值在 i = 0 处。<br>13 是所有美丽塔方案中的最大高度和<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>结合单调栈，用动态规划计算前缀后缀和</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-comment">//单调栈+前缀和</span><br>        <span class="hljs-comment">//max(prefix[i] + suffix[i] - maxHeights[i])</span><br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//单调非递减栈，栈里存的是索引</span><br>        <span class="hljs-comment">//左侧的非递减，i依次入栈，对第i个元素，不断从栈顶弹出比i大的元素，直到栈顶元素小于等于maxHeights[i]，假设此时栈顶元素为maxHeights[j]，则区间[j + 1, i - 1]之间的元素可以取到maxHeights[i]，此时prefix[i] = prefix[j] + (i - j) * maxHeights[i];</span><br>        <span class="hljs-comment">//左侧的非递增，就是右侧的非递减</span><br>        <span class="hljs-comment">//右侧的非递减，i依次入栈，对第i个元素，不断从栈顶弹出比i大的元素，直到栈顶元素小于等于maxHeights[i]，假设此时栈顶元素为maxHeights[j]，则区间[i + 1, j - 1]之间的元素可以取到maxHeights[i]，此时prefix[i] = prefix[j] + (j - i) * maxHeights[i];</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk1,stk2;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n)</span>, <span class="hljs-title">suffix</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">//处理单调非递减</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stk1.<span class="hljs-built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stk1.<span class="hljs-built_in">top</span>()]) &#123;<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stk1.<span class="hljs-built_in">empty</span>()) &#123;<br>                prefix[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(i + <span class="hljs-number">1</span>) * maxHeights[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prefix[i] = prefix[stk1.<span class="hljs-built_in">top</span>()] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(i - stk1.<span class="hljs-built_in">top</span>()) * maxHeights[i];<br>            &#125;<br>            stk1.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">//处理单调非递增，转为右侧单调非递减</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stk2.<span class="hljs-built_in">empty</span>() &amp;&amp; maxHeights[i] &lt; maxHeights[stk2.<span class="hljs-built_in">top</span>()]) &#123;<br>                stk2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stk2.<span class="hljs-built_in">empty</span>()) &#123;<br>                suffix[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(n - i) * maxHeights[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                suffix[i] = suffix[stk2.<span class="hljs-built_in">top</span>()] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(stk2.<span class="hljs-built_in">top</span>() - i) * maxHeights[i];<br>            &#125;<br>            stk2.<span class="hljs-built_in">push</span>(i);<br>            res = <span class="hljs-built_in">max</span>(res, prefix[i] + suffix[i] - maxHeights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2095</title>
    <link href="/2024/01/25/Leetcode2095/"/>
    <url>/2024/01/25/Leetcode2095/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2095-删除链表的中间节点"><a href="#Leetcode-2095-删除链表的中间节点" class="headerlink" title="Leetcode 2095 - 删除链表的中间节点"></a>Leetcode 2095 - 删除链表的中间节点</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/?envType=study-plan-v2&envId=leetcode-75">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/?envType=study-plan-v2&amp;envId=leetcode-75</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。</p><p>长度为 n 链表的中间节点是从头数起第 ⌊n &#x2F; 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。</p><p>对于 n &#x3D; 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img src="/image2095.png" alt="Alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs base">输入：head = [1,3,4,7,1,2,6]<br>输出：[1,3,4,1,2,6]<br>解释：<br>上图表示给出的链表。节点的下标分别标注在每个节点的下方。<br>由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。<br>返回结果为移除节点后的新链表<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>快慢指针，看情况要不要在首节点前加前驱节点</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteMiddle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || head -&gt; next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">//快慢指针</span><br>        ListNode* fast = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* slow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-keyword">while</span> (fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next) &#123;<br>            fast = fast -&gt; next -&gt; next;<br>            slow = slow -&gt; next;<br>        &#125;<br>        slow -&gt; next = slow -&gt; next -&gt; next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2765</title>
    <link href="/2024/01/25/Leetcode2765/"/>
    <url>/2024/01/25/Leetcode2765/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2765-最长交替子数组"><a href="#Leetcode-2765-最长交替子数组" class="headerlink" title="Leetcode 2765 - 最长交替子数组"></a>Leetcode 2765 - 最长交替子数组</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/longest-alternating-subarray/description/">https://leetcode.cn/problems/longest-alternating-subarray/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始的整数数组 nums 。如果 nums 中长度为 m 的子数组 s 满足以下条件，我们称它是一个 交替子数组 ：</p><p>m 大于 1 。<br>s1 &#x3D; s0 + 1 。<br>下标从 0 开始的子数组 s 与数组 [s0, s1, s0, s1,…,s(m-1) % 2] 一样。也就是说，s1 - s0 &#x3D; 1 ，s2 - s1 &#x3D; -1 ，s3 - s2 &#x3D; 1 ，s4 - s3 &#x3D; -1 ，以此类推，直到 s[m - 1] - s[m - 2] &#x3D; (-1)m 。<br>请你返回 nums 中所有 交替 子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。</p><p>子数组是一个数组中一段连续 非空 的元素序列。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：nums = [2,3,4,3,4]<br>输出：4<br>解释：交替子数组有 [3,4] ，[3,4,3] 和 [3,4,3,4] 。最长的子数组为 [3,4,3,4] ，长度为4 。<br></code></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>双指针<br>交替子数组满足nums[i] - nums[i - 1] &#x3D;&#x3D; 1, nums[i] - nums[i - 2] &#x3D;&#x3D; 0<br>nums[i] - nums[j] &#x3D;&#x3D; (len - 1) % 2</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">alternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//双指针，固定左端</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[r] - nums[l] == (len - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, len);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[r] - nums[r - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    l = r - <span class="hljs-number">1</span>;<br>                    res = <span class="hljs-built_in">max</span>(res, <span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = r;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>程序员转换产品经理问题</title>
    <link href="/2024/01/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BD%AC%E6%8D%A2%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/24/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BD%AC%E6%8D%A2%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员转换产品经理问题"><a href="#程序员转换产品经理问题" class="headerlink" title="程序员转换产品经理问题"></a>程序员转换产品经理问题</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p>无</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>公司的程序员不够用了，决定把产品经理都转变为程序员以解决开发时间长的问题。</p><p>在给定的矩形网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格;<br>值 1 代表产品经理;<br>值 2 代表程序员;<br>每分钟，任何与程序员(在 4 个正方向上)相邻的产品经理都会变成程序员。</p><p>返回直到单元格中没有产品经理为止所必须经过的最小分钟数。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dfs或bfs搜索问题<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] H)</span> &#123;<br>        <span class="hljs-comment">//BFS队列或者DFS递归去遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> H.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cols</span> <span class="hljs-operator">=</span> H[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">managers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//将所有程序员添加到队列，并统计产品经理的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>                <span class="hljs-keyword">if</span> (H[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (H[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    managers++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//上下左右四个方向遍历</span><br>        <span class="hljs-type">int</span>[][] directions = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; managers &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span>[] curr = queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : directions) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newRow</span> <span class="hljs-operator">=</span> curr[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newCol</span> <span class="hljs-operator">=</span> curr[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span class="hljs-number">0</span> &amp;&amp; newCol &lt; cols &amp;&amp; H[newRow][newCol] == <span class="hljs-number">1</span>) &#123;<br>                        H[newRow][newCol] = <span class="hljs-number">2</span>; <span class="hljs-comment">// 将产品经理转化为程序员</span><br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;newRow, newCol&#125;);<br>                        managers--;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            ans++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> managers == <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[][] H=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method(H);<br>        System.out.println(<span class="hljs-string">&quot;question4 result is:&quot;</span>+result);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>过河问题</title>
    <link href="/2024/01/24/%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/24/%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="过河问题"><a href="#过河问题" class="headerlink" title="过河问题"></a>过河问题</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p>无</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有n个人要过河，但是河边只有一艘船；</p><p>船每次最多坐三个人，每个人单独坐船过河的时间为a[i]；</p><p>两个人或者三个人一起坐船时，过河时间为他们所有人中的最长过河时间；</p><p>为了安全起见，要求每次至少有两个人才能过河。</p><p>问最短需要多少时间，才能把所有人送过河。</p><p>输入描述：</p><p>第一行是整数n，表示测试样例格式</p><p>每个测试样例的第一行是一个正整数n，表示参加过河的人数（2&lt;&#x3D;n&lt;100000）</p><p>第二行是n个正整数a[i] (0&lt;a[i]&lt;100000)，表示n个人单独过河的时间；</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">贪心<br>1.两个人或者三个人，取时间最长的<br>2.四个人<br>（1）最短的两个加最长的先过去，最短的两个回来，最短的加次长的过去<br>(a[0] + a[1] + a[3])+ (a[0] + a[1]) + (a[0] + a[1] + a[2]) = a[1] + a[2] + a[3]<br>（2）最短的三个过去，最短的两个回来，最短的两个带最长的过去（和第一种方案一样）<br>综上，四个人只有一个方案<br>3.四个人以上<br>（1）最短的两个带最长的过去，最短的再回来带次长的，依次带过去<br>(a[0] + a[1] + a[n - 1]) = a[n - 1]<br>（2）最短的三个过去，把第三个留在对岸，最短的两个回来，最短的带最长的两个过去，最短的和第三短的回来，每次把最长的两个送到对岸<br>(a[0] + a[1] + a[2]) + (a[0] + a[1]) + (a[0] + a[n - 1] + a[n - 2]) + (a[0] + a[2]) =  2 * a[2] + a[1] + a[n - 1]<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-comment">//一次带一个</span><br>            <span class="hljs-type">int</span> s1 = a[n - <span class="hljs-number">1</span>] + a[n - <span class="hljs-number">2</span>];<br>            <span class="hljs-comment">//两次带两个</span><br>            <span class="hljs-type">int</span> s2 = <span class="hljs-number">2</span> * a[<span class="hljs-number">2</span>] + a[<span class="hljs-number">1</span>] + a[n - <span class="hljs-number">1</span>];<br>            sum += <span class="hljs-built_in">min</span>(a[n - <span class="hljs-number">1</span>] + a[n - <span class="hljs-number">2</span>], <span class="hljs-number">2</span> * a[<span class="hljs-number">2</span>] + a[<span class="hljs-number">1</span>] + a[n - <span class="hljs-number">1</span>]);<br>            n -= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//可能剩3个或者4个人</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) &#123;<br>            sum += a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + a[n - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>            sum += a[<span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            sum += a[<span class="hljs-number">1</span>];<br>        &#125;<br>        cout&lt;&lt;sum&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode3012</title>
    <link href="/2024/01/22/Leetcode3012/"/>
    <url>/2024/01/22/Leetcode3012/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-3012-通过操作使数组长度最小"><a href="#Leetcode-3012-通过操作使数组长度最小" class="headerlink" title="Leetcode 3012 - 通过操作使数组长度最小"></a>Leetcode 3012 - 通过操作使数组长度最小</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/minimize-length-of-array-using-operations/description/">https://leetcode.cn/problems/minimize-length-of-array-using-operations/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始的整数数组 nums ，它只包含 正 整数。</p><p>你的任务是通过进行以下操作 任意次 （可以是 0 次） 最小化 nums 的长度：</p><p>在 nums 中选择 两个不同 的下标 i 和 j ，满足 nums[i] &gt; 0 且 nums[j] &gt; 0 。<br>将结果 nums[i] % nums[j] 插入 nums 的结尾。<br>将 nums 中下标为 i 和 j 的元素删除。<br>请你返回一个整数，它表示进行任意次操作以后 nums 的 最小长度 。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">考虑这个例子：nums=[2,3,4,5,6]，每次操作都可以选择 2和另一个数字 x，由于 x&gt;2，所以 2 mod x=2 ，于是操作等价于：移除x<br>如果数组中最小值只有一个，返回1<br>不止一个，也能构造出小于当前最小值m的值，返回1，除非所有的数都是m的倍数，那么先清除m之外的元素，返回的是(m + 1)/2<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumArrayLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = *<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x % m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (ranges::<span class="hljs-built_in">count</span>(nums,m) + <span class="hljs-number">1</span>)/ <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2736</title>
    <link href="/2024/01/22/Leetcode2736/"/>
    <url>/2024/01/22/Leetcode2736/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2736-最大和查询"><a href="#Leetcode-2736-最大和查询" class="headerlink" title="Leetcode 2736 - 最大和查询"></a>Leetcode 2736 - 最大和查询</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/maximum-sum-queries/description/">https://leetcode.cn/problems/maximum-sum-queries/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你两个长度为 n 、下标从 0 开始的整数数组 nums1 和 nums2 ，另给你一个下标从 1 开始的二维数组 queries ，其中 queries[i] &#x3D; [xi, yi] 。</p><p>对于第 i 个查询，在所有满足 nums1[j] &gt;&#x3D; xi 且 nums2[j] &gt;&#x3D; yi 的下标 j (0 &lt;&#x3D; j &lt; n) 中，找出 nums1[j] + nums2[j] 的 最大值 ，如果不存在满足条件的 j 则返回 -1 。</p><p>返回数组 answer ，其中 answer[i] 是第 i 个查询的答案。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">单调栈+二分查找<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maximumSumQueries</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; sortedNums;<br>        vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; sortedQueries;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sortedNums.<span class="hljs-built_in">emplace_back</span>(nums1[i], nums2[i]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(sortedNums.<span class="hljs-built_in">begin</span>(), sortedNums.<span class="hljs-built_in">end</span>(), greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sortedQueries.<span class="hljs-built_in">emplace_back</span>(i, queries[i][<span class="hljs-number">0</span>], queries[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(sortedQueries.<span class="hljs-built_in">begin</span>(), sortedQueries.<span class="hljs-built_in">end</span>(), [](tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;a, tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a) &gt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>        &#125;);<br><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stk;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(queries.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[i, x, y] : sortedQueries) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; sortedNums.<span class="hljs-built_in">size</span>() &amp;&amp; sortedNums[j].first &gt;= x) &#123;<br>                <span class="hljs-keyword">auto</span> [num1, num2] = sortedNums[j];<br>                <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">back</span>().second &lt;= num1 + num2) &#123;<br>                    stk.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">back</span>().first &lt; num2) &#123;<br>                    stk.<span class="hljs-built_in">emplace_back</span>(num2, num1 + num2);<br>                &#125;<br>                j++;<br>            &#125;<br>            <span class="hljs-type">int</span> k = <span class="hljs-built_in">lower_bound</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">make_pair</span>(y, <span class="hljs-number">0</span>)) - stk.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">if</span> (k &lt; stk.<span class="hljs-built_in">size</span>()) &#123;<br>                answer[i] = stk[k].second;<br>            &#125;<br>        &#125;    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stk.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            cout &lt;&lt; stk[i].first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; stk[i].second &lt;&lt; endl;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2352</title>
    <link href="/2024/01/22/LeetCode2352/"/>
    <url>/2024/01/22/LeetCode2352/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2352-相等行列对"><a href="#Leetcode-2352-相等行列对" class="headerlink" title="Leetcode 2352 - 相等行列对"></a>Leetcode 2352 - 相等行列对</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/equal-row-and-column-pairs/description/">https://leetcode.cn/problems/equal-row-and-column-pairs/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">方法一：哈希表存一行vector&lt;int&gt;，遍历列的时候再求数目。<br>方法二：方法一的基础上，一行存为字符串<span class="hljs-built_in">hash</span>,str = str * 13 + x<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">equalPairs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">//字符串hash</span><br>        unordered_map&lt;ULL, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : grid) &#123;<br>            ULL str = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : row) &#123;<br>                str = str * <span class="hljs-number">131</span> + x;<br>            &#125;<br>            hash[str]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            ULL str = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                str = str * <span class="hljs-number">131</span> + grid[i][j];<br>            &#125;<br>            ans += hash[str];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode649</title>
    <link href="/2024/01/22/Leetcode649/"/>
    <url>/2024/01/22/Leetcode649/</url>
    
    <content type="html"><![CDATA[<p>#Leetcode 649 - Dota2参议院</p><p>###题目链接：<br><a href="https://leetcode.cn/problems/dota2-senate/description/">https://leetcode.cn/problems/dota2-senate/description/</a><br>###题目大意：<br>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：</p><p>禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。<br>宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。<br>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">RDRRDDDDDRR<br>10110011100<br>00110000100<br>00010000000<br>贪心，按次ban，折半遍历O(n * logn)<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">predictPartyVictory</span><span class="hljs-params">(string senate)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = senate.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt_R = <span class="hljs-number">0</span>, cnt_D = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> live_R = <span class="hljs-number">0</span>, live_D = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//记录存活状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">state</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : senate) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                live_R++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                live_D++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (live_R != <span class="hljs-number">0</span> &amp;&amp; live_D != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (state[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (senate[i] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123; <span class="hljs-comment">//下一个投票的是R且他存活</span><br>                        <span class="hljs-keyword">if</span> (cnt_D &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//被前面ban</span><br>                            state[i] = <span class="hljs-literal">false</span>;<br>                            live_R--;<br>                            cnt_D--;<br>                        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//未被前面ban</span><br>                            cnt_R++;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//下一个投票的是D且他存活</span><br>                        <span class="hljs-keyword">if</span> (cnt_R &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//被前面ban</span><br>                            state[i] = <span class="hljs-literal">false</span>;<br>                            live_D--;<br>                            cnt_R--;<br>                        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//未被前面ban</span><br>                            cnt_D++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> live_R &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;Radiant&quot;</span> : <span class="hljs-string">&quot;Dire&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode82</title>
    <link href="/2024/01/22/Leetcode82/"/>
    <url>/2024/01/22/Leetcode82/</url>
    
    <content type="html"><![CDATA[<p>#Leetcode 82 - 删除排序链表中的重复元素 II</p><p>###题目链接：<br><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a><br>###题目大意：<br>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br>示例1:<br><img src="/image82.png" alt="Alt text"><br>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">遍历每一个节点，如果这个节点的下一节点值和下下一节点值相同，将下一节点值当作判断值，进入循环，删除下一节点以及后续相同值节点。<br>由于首节点有可能被删除，新建一个前驱节点，返回pre-&gt;next<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* cur = pre;<br>        <span class="hljs-keyword">while</span> (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; next) &#123;<br>            <span class="hljs-keyword">if</span> (cur -&gt; next -&gt; val == cur -&gt; next -&gt; next -&gt; val) &#123;<br>                <span class="hljs-type">int</span> t = cur -&gt; next -&gt; val;<br>                <span class="hljs-keyword">while</span> (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val == t) &#123;<br>                    cur -&gt; next = cur -&gt; next -&gt; next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur -&gt; next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre -&gt; next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TSP</title>
    <link href="/2024/01/22/TSP/"/>
    <url>/2024/01/22/TSP/</url>
    
    <content type="html"><![CDATA[<p>#TSP - Traveling Salesman Problem</p><p>###题目链接：<br>无<br>###题目大意：<br>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。<br>由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>输入描述:<br>第一个入参H[N][N]：表示H城市间的车票价钱N行N列的矩阵，N表示城市个数(1&lt;n≤20，包括北京)</p><p>输出描述:<br>最小车费花销s</p><p>说明<br>共4 个城市，城市1 和城市 1 的车费为0，城市 1 和城市 2之间的车费为 2，城市 1 和城市3之间的车费为 6，城市 1和城市 4 之间的车费为5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。</p><p>###分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">旅行商问题，组合优化中的一个NP完全问题，带权无向图求最大最小权值，动态规划+状态压缩<br>当数量规模过大时，dp解决的效率不如采用近似算法或神经算法等<br></code></pre></td></tr></table></figure><p>###代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] H)</span>&#123;<br>    <span class="hljs-comment">//内部逻辑由参赛老师自行实现</span><br>    <span class="hljs-comment">//题目缺失关键信息，第一个城市应该是北京吧</span><br>    <span class="hljs-comment">//dp[state][city]表示在state状态下，位于city城市的最小花销</span><br>    <span class="hljs-comment">//dp[state][i] = Math.min(dp[state][j], dp[state ^ (1 &lt;&lt; j)][i] + H[i][j]);</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> H.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">states</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; <span class="hljs-comment">//用二进制表示城市访问状态</span><br>    <span class="hljs-comment">//初始化dp</span><br>    <span class="hljs-type">int</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span> &lt;&lt; n][n];<br>    <span class="hljs-comment">//设置初始值且避免整数溢出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;<br>        Arrays.fill(dp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-comment">//初始状态，dp[0001][0] = 0</span><br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; state &lt;= states; state++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//上一个访问的城市和上一次访问后的state对应值需要一致</span><br>            <span class="hljs-keyword">if</span> ((state &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-comment">//上一次访问城市和下一次访问城市不用，且下一个访问的城市在访问后的state对应值需要一致</span><br>                    <span class="hljs-keyword">if</span> (i != j &amp;&amp; (state &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                        dp[state][j] = Math.min(dp[state][j], dp[state ^ (<span class="hljs-number">1</span> &lt;&lt; j)][i] + H[i][j]);<br>                        <span class="hljs-comment">//System.out.println((state ^ (1 &lt;&lt; j)) + &quot; &quot; + state + &quot; &quot; + i + &quot; &quot; + j + &quot; &quot; + dp[state][j]);</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-comment">//求最后一个城市返回0的最小花销</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        result = Math.min(result, dp[states][i] + H[i][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span>[][] H=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method(H);<br>    System.out.println(<span class="hljs-string">&quot;question2 result is:&quot;</span>+result);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ideal</title>
    <link href="/2024/01/17/ideal/"/>
    <url>/2024/01/17/ideal/</url>
    
    <content type="html"><![CDATA[<h1 id="Ideal"><a href="#Ideal" class="headerlink" title="Ideal"></a>Ideal</h1><h3 id="1-启动失败"><a href="#1-启动失败" class="headerlink" title="1.启动失败"></a>1.启动失败</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">报错内容：No active profile <span class="hljs-built_in">set</span>, falling back to default profiles: default<br>原因：23年版ideal默认隐藏VM options，有的项目通过Program arguments配置环境变量，有的通过VM options，填错就会找不到配置环境<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2024/01/15/Linux/"/>
    <url>/2024/01/15/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="1-修改用户密码"><a href="#1-修改用户密码" class="headerlink" title="1.修改用户密码"></a>1.修改用户密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ passwd //修改当前用户密码<br>$ sudo passwd [用户名] //修改指定用户密码<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>how to use kindle</title>
    <link href="/2024/01/13/how-to-use-kindle/"/>
    <url>/2024/01/13/how-to-use-kindle/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用总结"><a href="#Hexo使用总结" class="headerlink" title="Hexo使用总结"></a>Hexo使用总结</h1><h2 id="1-如何传文件到Kindle"><a href="#1-如何传文件到Kindle" class="headerlink" title="1.如何传文件到Kindle"></a>1.如何传文件到Kindle</h2><h5 id="（1）设备本地"><a href="#（1）设备本地" class="headerlink" title="（1）设备本地"></a>（1）设备本地</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">数据线直连Kindle传<br></code></pre></td></tr></table></figure><h5 id="（2）云图书馆（推荐，各设备可同步进度）"><a href="#（2）云图书馆（推荐，各设备可同步进度）" class="headerlink" title="（2）云图书馆（推荐，各设备可同步进度）"></a>（2）云图书馆（推荐，各设备可同步进度）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过微信传输文件，将文本（txt等格式文件）传至手机微信<br>微信点击文件，用其他应用打开，选择Kindle手机app打开<br>修改文件后缀，加上【.mobi】传至Kindle云图书馆，设备同步数据即可看到电子书<br></code></pre></td></tr></table></figure><h2 id="2-如何使用Kindle"><a href="#2-如何使用Kindle" class="headerlink" title="2.如何使用Kindle"></a>2.如何使用Kindle</h2><h5 id="（1）退出阅读模式"><a href="#（1）退出阅读模式" class="headerlink" title="（1）退出阅读模式"></a>（1）退出阅读模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">点击电子书上方即可弹出bar<br></code></pre></td></tr></table></figure><h5 id="（2）云图书馆（推荐，各设备可同步进度）-1"><a href="#（2）云图书馆（推荐，各设备可同步进度）-1" class="headerlink" title="（2）云图书馆（推荐，各设备可同步进度）"></a>（2）云图书馆（推荐，各设备可同步进度）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过微信传输文件，将文本（txt等格式文件）传至手机微信<br>微信点击文件，用其他应用打开，选择Kindle手机app打开<br>修改文件后缀，加上【.mobi】传至Kindle云图书馆，设备同步数据即可看到电子书<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode2645</title>
    <link href="/2024/01/12/Leetcode2645/"/>
    <url>/2024/01/12/Leetcode2645/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-2645-构造有效字符串的最小插入数"><a href="#Leetcode-2645-构造有效字符串的最小插入数" class="headerlink" title="Leetcode 2645 - 构造有效字符串的最小插入数"></a>Leetcode 2645 - 构造有效字符串的最小插入数</h1><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/description/">https://leetcode.cn/problems/minimum-additions-to-make-valid-string/description/</a></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个字符串 word ，你可以向其中任何位置插入 “a”、”b” 或 “c” 任意次，返回使 word 有效 需要插入的最少字母数。<br>如果字符串可以由 “abc” 串联多次得到，则认为该字符串 有效 。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">动态规划：<br>1.word[i] 单独存在于一组 abc 中，dp[i] = dp[i - 1] + 2<br>2.如果word[i] &gt; word[i - 1]，则word[i]和word[i - 1]在同一组中，那么 dp[i] = dp[i - 1] - 1<br>例子：<br>abcbabbc<br>021024354<br></code></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(string word)</span> </span>&#123;s<br>        <span class="hljs-type">int</span> n = word.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (word[i] &gt; word[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>transform2Json</title>
    <link href="/2024/01/12/transform2Json/"/>
    <url>/2024/01/12/transform2Json/</url>
    
    <content type="html"><![CDATA[<p>#报文转Json格式<br><!DOCTYPE html></p><html lang="en"><head>    <title>        json格式化    </title>    <meta charset="UTF-8"></head><script type="text/javascript">    function initStyle() {        document.body.style.width = window.innerWidth;        document.getElementById("output_value").style.height = window.innerHeight + "px";    }</script><body onload="initStyle()">    <textarea id="content_value" style="width: 100%;height:150px;"></textarea>    <div style="width: 100%;text-align: center;">        <input type="button" value="格式化" onclick="check()">    </div>    <textarea id="output_value" style="width: 100%;"></textarea></body><script type="text/javascript">    function check() {        var text_value = document.getElementById("content_value").value;        if (text_value == "") {            alert("不能为空");            return false;        } else {            var res = "";            for (var i = 0, j = 0, k = 0, ii, ele; i < text_value.length; i++) {                //k:缩进 j:个数                ele = text_value.charAt(i);                if (j % 2 == 0 && (ele == "}" || ele == "]")) {                    k--;                    for (ii = 0; ii < k; ii++) {                        ele = "\t" + ele;                    }                    ele = "\n" + ele;                } else if (j % 2 == 0 && (ele == "{" || ele == "[")) {                    ele += "\n";                    k++;                    for (ii = 0; ii < k; ii++) {                        ele += "\t";                    }                } else if (j % 2 == 0 && ele == ",") {                    ele += "\n";                     for (ii = 0; ii < k; ii++) {                        ele += "\t";                    }                } else if (ele == "\"") {                    j++;                }                res += ele;            }            document.getElementById("output_value").value = res;        }    }</script></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2024/01/12/hexo/"/>
    <url>/2024/01/12/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo使用总结"><a href="#Hexo使用总结" class="headerlink" title="Hexo使用总结"></a>Hexo使用总结</h1><h2 id="1-如何更换主题"><a href="#1-如何更换主题" class="headerlink" title="1.如何更换主题"></a>1.如何更换主题</h2><h5 id="（1）hexo根目录下"><a href="#（1）hexo根目录下" class="headerlink" title="（1）hexo根目录下"></a>（1）hexo根目录下</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br>$ <span class="hljs-built_in">cd</span> fluid<br>$ npm install<br></code></pre></td></tr></table></figure><h5 id="（2）修改Hexo根目录下-config-yml"><a href="#（2）修改Hexo根目录下-config-yml" class="headerlink" title="（2）修改Hexo根目录下_config.yml"></a>（2）修改Hexo根目录下_config.yml</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid<br></code></pre></td></tr></table></figure><h5 id="（3）清除缓存"><a href="#（3）清除缓存" class="headerlink" title="（3）清除缓存"></a>（3）清除缓存</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><h5 id="（4）构建页面"><a href="#（4）构建页面" class="headerlink" title="（4）构建页面"></a>（4）构建页面</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><h5 id="（5）本地调试"><a href="#（5）本地调试" class="headerlink" title="（5）本地调试"></a>（5）本地调试</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><h5 id="（6）上传版本（版本更新大概需要2min）"><a href="#（6）上传版本（版本更新大概需要2min）" class="headerlink" title="（6）上传版本（版本更新大概需要2min）"></a>（6）上传版本（版本更新大概需要2min）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><h5 id="如果报错：无权限或者文件不存在，检查是否有权限上传-key-或-config-yml文件配置是否正确"><a href="#如果报错：无权限或者文件不存在，检查是否有权限上传-key-或-config-yml文件配置是否正确" class="headerlink" title="如果报错：无权限或者文件不存在，检查是否有权限上传(key)或_config.yml文件配置是否正确"></a>如果报错：无权限或者文件不存在，检查是否有权限上传(key)或_config.yml文件配置是否正确</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:hide-in-bed/blog.git<br>  branch: master<br></code></pre></td></tr></table></figure><h5 id="如果报错：ssh-connect-to-host-github-com-port-22-Connection-timed-out"><a href="#如果报错：ssh-connect-to-host-github-com-port-22-Connection-timed-out" class="headerlink" title="如果报错：ssh: connect to host github.com port 22: Connection timed out"></a>如果报错：ssh: connect to host github.com port 22: Connection timed out</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: git@github.com:hide-in-bed/blog.git<br>  branch: master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/10/hello-world/"/>
    <url>/2024/01/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
